# Optimized Multiplication Generator in ARM64 Assembly

## Project Overview

This project automatically generates an ARM64 assembly file (`kefel.s`) that multiplies a 64-bit integer by a constant **k** using only shift (`lsl`), add (`add`), and subtract (`sub`) instructions. By avoiding the generic `mul` instruction, the generated code is faster and uses fewer cycles on ARM64 processors.

## Getting Started

1. Save your Java generator as `Kefel.java`.
2. Compile the Java program:

   ```sh
   javac Kefel.java
   ```
3. Run the generator with your chosen constant (e.g., k=14):

   ```sh
   java Kefel 14
   ```

   This produces `kefel.s` in the current directory.
4. Obtain the provided `test.c` driver from the course website.
5. Compile both files into an executable:

   ```sh
   gcc test.c kefel.s -o test
   ```
6. Execute and verify the results:

   ```sh
   ./test
   ```
7. Submit only the `Kefel.java` file.
8. Clean up your directory:

   ```sh
   rm -f Kefel.class kefel.s test
   ```

> The code can be tested on any 64-bit Unix system (Linux, macOS, etc.).

## Implementation Details

* The Java program reads a single integer argument **k**.
* It outputs an ARM64 assembly file defining the function `kefel`, which:

  * Accepts a 64-bit integer in register `x0`.
  * Returns the product `k * x0` in register `x0`.

## Optimization Rules

1. **Single 1-bit**: if `k` is a power of two, use one shift.
   *Example:* k=8 → `lsl x0, x0, #3`.
2. **Two consecutive 1-bits**: sum of two shifts.
   *Example:* k=6 → `(x << 2) + (x << 1)`.
3. **Run of ≥3 consecutive 1-bits**: difference of two shifts.
   *Example:* k=14 → `(x << 4) - (x << 1)`.
4. **Fallback**: for all other bit patterns, express `k` as a sum of individual shifts, minimizing redundant `lsl #0` operations.
5. **File header and label**: every `kefel.s` must start with:

   ```asm
   .section .text
   .globl   kefel
   kefel:
       // Your optimized code here
       ret
   ```

## ARM64 Assembly Examples

### Non-optimized example for k = 14

This version uses three shift/add steps:

```asm
.section .text
.globl   kefel
kefel:
    // Compute 14*x by summing 8x + 4x + 2x:
    mov x1, x0        // x1 = x
    lsl x0, x0, #3    // x0 = x << 3 = 8x
    mov x2, x1        // x2 = x
    lsl x2, x2, #2    // x2 = x << 2 = 4x
    add x0, x0, x2    // x0 = 12x
    mov x2, x1        // x2 = x
    lsl x2, x2, #1    // x2 = x << 1 = 2x
    add x0, x0, x2    // x0 = 14x
    ret
```

### Optimized example for k = 14

This version factors 14 as 16 - 2:

```asm
.section .text
.globl   kefel
kefel:
    mov x1, x0        // x1 = x
    lsl x0, x0, #4    // x0 = x << 4 = 16x
    lsl x1, x1, #1    // x1 = x << 1 = 2x
    sub x0, x0, x1    // x0 = 16x - 2x = 14x
    ret
```

## Testing Recommendations

* Test edge cases: k=0, k=1.
* Verify powers of two (k=2, 4, 8, ...).
* Try mixed patterns: k=3 (11₂), k=7 (111₂), k=13 (1101₂), k=21 (10101₂).
* Ensure the result in `x0` matches a standard multiplication.

---

*Generated by Kefel.java*
